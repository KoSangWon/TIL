# 클로저
- 보다 안전한 코드를 만들고 싶다면 클로저를 적극 활용해야 한다.
- 함수형 프로그래밍 언어로서의 특징이다. 
- 클로저는 자바스크립트의 전유물이 아니다. 함수형이라면 클로저를 모두 지원한다.

> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다. by MDN => 그 함수의 렉시컬 환경과 그 함수가 선언된 렉시컬 환경, 이 2개를 항상 가지고 다니는 것이 클로저다
- 렉시컬 환경이란? 렉시컬 스코프의 결과물이다. 스코프라고 생각하면 된다. 함수와 그 함수의 상위 스코프의 조합이다.

- 이론적으로 말하면 모든 함수는 클로저이다. 왜냐? 자신의 렉시컬 환경 뿐만 아니라 상위 스코프 렉시컬 환경을 가지고 있기 때문이다. 그래서 기본적으로 자바스크립트의 모든 함수는 클로저이다.

## 3. 클로저와 렉시컬 환경
```js
const x = 1;

// ①
function outer() {
  const x = 10;
  const inner = function () { console.log(x); }; // ②
  return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.
const innerFunc = outer(); // ③
innerFunc(); // ④ 10
```

- inner함수는 outer 내부에 존재한다. inner의 상위 스코프는 outer 렉시컬 환경이다. inner함수는 또한 본인의 렉시컬 환경을 가지고 있다. 정확히 얘기하면 자신의 상위 스코프를 본인이 만들어낸 함수 객체의 내부 슬롯 [[Environment]]의 참조값으로 가지고 있다.


- 클로저를 만드려면 중첩 함수가 있어야한다. 중첩 함수가 외부 함수의 life cycle보다 더 오래 살아남아야 한다. 즉, 중첩 함수를 return 해줘야 한다.
- 일반적으로 클로저는 무엇이냐? (최적화의 관점)
  - 내부 함수가 외부 함수보다 더 오래 살아남아야 한다.(대표적인 방법이 return 이다.)
  - 그 오래 살아 남은 외부 함수가 상위 스코프의 식별자 하나라도 보고 있어야 한다.

- 그림을 그릴 줄 알아야 한다.
- 좁은의미로 **클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적이다.**

- 결론
  - 넓은 의미: 그 함수와 그 함수가 선언된 렉시컬 환경과의 조합
  - 좁은 의미: 외부 함수, 중첩 함수가 있는 상황에서 외부 함수보다 중첩 함수가 더 오래 살아남는 경우, 이 중첩함수가 벌써 소멸한 외부 함수의 식별자를 바라보고 있는 함수를 클로저라고 할 수 있다.
  - 외부 함수의 실행 컨텍스트의 실행 컨텍스트는 pop되어도 중첩 함수가 외부 환경에 대한 참조를 가지고 있기 때문에 발생한다.


## 4. 클로저의 활용
- **클로저는 상태(state)를 안전하게 변경하고 유지하기 위해 사용한다.** 다시 말해, 상태가 의도치 않게 변경되지 않도록 **상태를 안전하게 은닉(information hiding)** 하고 **특정 함수에게만 상태 변경을 허용**하기 위해 사용한다.


- 클로저를 만들 때 즉시 실행 함수를 많이 사용한다. 
```js
// 함수를 반환하는 고차 함수
// 이 함수는 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.
const counter = (function () {
  // 카운트 상태를 유지하기 위한 자유 변수
  let counter = 0;

  // 함수를 인수로 전달받는 클로저를 반환
  return function (predicate) {
    // 인수로 전달 받은 보조 함수에 상태 변경을 위임한다.
    counter = predicate(counter);
    return counter;
  };
}());

// 보조 함수
function increase(n) {
  return ++n;
}

// 보조 함수
function decrease(n) {
  return --n;
}

// 보조 함수를 전달하여 호출
console.log(counter(increase)); // 1
console.log(counter(increase)); // 2

// 자유 변수를 공유한다.
console.log(counter(decrease)); // 1
console.log(counter(decrease)); // 0
```
- **즉시 실행 함수를 사용함으로써 두번 만들지 않고 한번만 만듦으로써 렉시컬 환경을 하나만 만들자. 위 코드는 암기해두는 것이 좋다.**

## 5. 캡슐화와 정보 은닉
- 캡슐화(encapsulation)는 객체의 상태(state)를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작(behavior)인 메서드를 하나로 묶는 것을 말한다. 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉(information hiding)이라 한다.

- 정보 은닉은 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방지해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도(coupling)를 낮추는 효과가 있다.


- 결합도 & 응집도 찾아보기
  - https://medium.com/@jang.wangsu/%EC%84%A4%EA%B3%84-%EC%9A%A9%EC%96%B4-%EC%9D%91%EC%A7%91%EB%8F%84%EC%99%80-%EA%B2%B0%ED%95%A9%EB%8F%84-b5e2b7b210ff

