# 함수
## 1. 함수란?
- 매개변수는 변수이다. var 키워드를 안붙인다. input 즉, 외부의 값을 받아 출력을 내보내는 과정이 함수이다.
- **함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
```js
function add(x, y) { // 함수 선언
  return x + y;
}
```
- 함수는 호출이 되어야 실행된다. 미리 만들어놓을 필요가 없다.
- 함수 내부로 입력을 전달받는 변수를 **매개 변수(parameter)**, 입력을 **인수(argument)**, 출력을 **반환값(return value)** 이라 한다. 

## 2. 함수의 사용 이유
- 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.

## 3. 함수 리터럴
- 자바스크립트의 함수는 객체 타입의 값이다. 따라서 숫자 값을 숫자 리터럴로 생성하고 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있다. 함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다.
```js
// 변수에 함수 리터럴을 할당
var f = function add(x, y) {
  return x + y;
};
```
- add라는 함수 이름을 제거해도 문제 없다.
- 함수 리터럴의 구성 요소는 다음과 같다.
  - 함수 이름, 매개변수 목록, 함수 몸체

## 4. 함수 정의
- 함수 선언문
```js
function add(x, y) {
  return x + y;
}
```

- 함수 표현식 
```js
var add = function (x, y) {
  return x + y;
};
```



- 아래 예시를 보자.
```js
function add(x, y) {
  return x + y;
}
```
- 함수 선언문일 수도 함수 리터럴일 수 도있다. 값이 오지 않아도 되는 곳이면 함수 선언문으로 평가한다. 값이 와야 되는 곳이면 함수 리터럴로 평가된다.
- 함수 선언문으로 평가되나 함수 리털로 평가되나 함수가 생성되는 것은 똑같다. 차이점은 있다.
- 아래 예시에서는 암묵적으로 식별자를 만든다.
```js
// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
};

// 함수 호출
console.log(add(2, 5)); // 7
```

- 함수 선언문은 표현식이 아니다. 크롬 개발자 도구에서 함수 선언문을 실행하면 완료 값 undefined가 출력된다. 
- **함수 선언문은 런타임 이전에 함수 객체가 만들어지고 함수 객체를 만들어지는 식별자가 만들어진다.**
- **함수 표현식은 선언과 할당이다. var add는 런타임 이전에, 할당은 런타임 도중에 알어난다.**
- 따라서, 호이스팅은 함수 호이스팅, 변수 호이스팅 2개가 일어난다. 


- 함수 선언식과 함수 표현식의 차이를 알고 쓰자.
```js
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```

## 5. 함수 호출
### 5.1. 매개변수와 인수
- arguments 객체는 함수를 정의할 때, 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다. 
### 5.2. 인수 확인
- `function add(x, y) { return x + y; }`라는 것을 봤을 때 당연히 숫자가 오겠지..라는 생각을 하면 안된다. 타입 체크를 항상 생각해야한다. 이러한 것이 싫다는 이유로 타입스크립트를 도입하는 회사가 많다.
- 매개변수에 초기값을 설정하는 것도 좋지 않다. 논리상 흐름이 깨질 수도 있기 때문이다. 그러므로 순수함수를 사용하자!!!!!(의견)
```js
function add(x, y) {
  if (typeof x !== 'number' || typeof y !== 'number') {
    // 매개변수를 통해 전달된 인수의 타입이 부적절한 경우 에러를 발생시킨다.
    throw new TypeError('인수는 모두 숫자 값이어야 합니다.');
  }

  return x + y;
}

console.log(add(2));        // TypeError: 인수는 모두 숫자 값이어야 합니다.
console.log(add('a', 'b')); // TypeError: 인수는 모두 숫자 값이어야 합니다.
```
- 위 코드는 배보다 배꼽이 더 큰 코드이다. 차라리 TypeScript를 쓰자.
- try/catch 문으로 사용할 수 있음.
- 함수보다는 연산자를 사용하자.
  - `2**2**2`를 사용하는 것이 Math.pow(Math.pow(2, 2), 2) 보다 편하다.
- arguments는 length가 생략되어 있다.  arguments는 가변인자 함수를 만들 때 사용한다.
```js
function sum(){
  var res = 0;
  for(var i = 0; i < arguments.length; i++){ // 유사배열이므로 for문을 사용할 수 있다.
    res += arguments[i]; 
  }
  return res;
}
console.log(sum(2,5,10));
```
- 아래처럼 바꿀 수도 있다.
```js
function sum(...args){
  return args.reduce((pre, cur) => pre + cur, 0)
}
```

### 5.3. 매개변수의 최대 개수
```js
$.ajax({
  method: 'POST',
  url: '/user',
  data: { id: 1, name: 'Lee' },
  cache: false
});
```
- 위에서 객체 리터럴로 전달하는 것의 의미는 'ajax야 너만 이 객체를 써' 라는 의미이다. 
- 만약 변수에 담아서 객체를 넘긴다면 외부에서 제어를 할 수 있게 되므로 좋지 않다. 따라서 변수는 정말 필요할 때만 선언하자.

## 6. 참조에 의한 전달과 외부 상태의 변경
```js
// 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num); // 100
console.log(person); // {name: "Lee"}

// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.
changeVal(num, person);

// 원시값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다.
console.log(person); // {name: "Kim"}
```
- 순수함수가 아닌 함수를 비순수함수라고 한다. 순수함수는 동일한 인수가 전달되면 언제나 동일한 반환값을 리턴한다. 
- 비순수함수는 동일한 인수가 전달되었을 때 동일하지 않은 결과를 리턴하는 경우가 있다. 비순수함수는 테스트 할 때 곤란하다. 그래서 우리는 순수함수를 지향해야 한다.
- 기본적으로 객체를 인수로 전달할 때는 해당 객체가 바뀌는지 여부를 항상 확인해야 한다. 만약 정말 객체를 담은 변수를 매개변수로 쓰고 싶다면 copy 해서 쓰라는 의견도 있다. 

## 7. 다양한 함수의 형태
### 7.1. 즉시 실행 함수
- 옛날에는 즉시 실행 함수를 많이 사용했지만 현재는 많이 사용하지 않는다. 왜냐하면 요즘은 모듈별로 개발을 하기 때문에 파일 스코프를 가지게 된다.
```js
// 익명 즉시 실행 함수
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());
```
- 무기명으로 해도 된다. 기명으로 하면 무슨 일을 하는 함수인지 알 수 있다. 또한, 재귀도 돌 수 있다. 디버깅할 때도 용이하다. 그런 경우가 아니라면 일반적으로 무기명으로 사용한다.
```js
(function () {
  // ...
}());

// 아래 방법을 추천 함. 왜냐하면 화살표 함수에서 위 방법은 안됨.
(function () {
  // ...
})();
```

### 7.2. 재귀 함수
- 재귀는 반복문의 대용이다. 
- 재귀는 항상 탈출조건을 써야한다. 재귀함수는 조심히 써야한다. 스택 오버플로 에러를 발생시킬 수도 있다.

### 7.3. 중첩 함수
- 함수 내부에 정의된 함수를 중첩 함수(nested function) 또는 내부 함수(inner function)라 한다. 그리고 중첩 함수를 포함하는 함수를 외부 함수(outer function)라 부른다. 일반적으로 중첩 함수를 자신을 포함하는 외부 함수를 돕는 헬퍼 함수(helper function)의 역할을 한다.

```js
function outer() {
  var x = 1;

  // 중첩 함수
  function inner() {
    var y = 2;
    // 외부 함수의 변수를 참조할 수 있다.
    console.log(x + y); // 3
  }

  inner();
}

outer();
```
- 왜 inner 함수를 선언할까? 
  - 밖에서 inner 함수를 쓰지 못하게 하기 위함
  - 내부에서 여러번 쓰게 하기 위함
  - 클로저를 만들기 위함

### 7.4. 콜백 함수
- 중첩 함수는 헬퍼 함수를 가지고 있다. 헬퍼 함수 이외의 도움을 받을 수 없다.
- 콜백 함수는 헬퍼 함수를 바꿔낄 수 있다.
- **함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라고 한다. **
- 고차함수: 함수를 인자로 받는 함수 or 함수를 리턴하는 함수
- 내부 함수로 만들지 그랬어?에 대한 대답으로는 내부 함수로 만들기엔 그 함수로 만들때 이 함수가 필요할지 몰랐다. 
```js
// 외부에서 전달받은 f를 n만큼 반복 호출한다
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i); // i를 전달하면서 f를 호출
  }
}

var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll); // 0 1 2 3 4

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logOdds); // 1 3
```
- 위에서 logAll을 따로 정의한 이유는 다량으로 호출될 수 있기 때문이다. 


```js
setTimeout(()=>console.log('hi'),1000);
```
- setTimeout은 브라우저가 호출한다. setTimeout이 첫번째 인자를 호출하지 않는다.


### 7.5. 순수 함수와 비순수 함수
- 함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수(pure function)라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 비순수 함수(impure function)라고 한다.

- 함수형은 기본적으로 순수함수를 지향한다. 무조건 순수함수를 만들어라는 아니다. 또, 부수 효과를 최소화 하라는 것이다. 
- 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성(immutability)을 지향하는 프로그래밍 패러다임이다. 
