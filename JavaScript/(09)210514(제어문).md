# 제어문

- 제어문은 안좋은 것이다. 흐름을 깬다. 웬만하면 안쓰려고 해야한다.
- 특히 for문이 문제다. for 문은 사람이 직관적으로 흐름을 알기 힘들다. 실수로 연결될 가능성이 매우 높다.

## 1. 블록문
- {} 은 객체일까 블록문일까? 중의적 의미를 가지고 있다. 어떤 때는 객체 리터럴의 기호이고 어떤 때는 블록문이다.
- js 는 {}를 보면 블록문으로 인식한다.
- 값이 위치할 수 있는 영역으로 {}를 넣으면 객체 리터럴이 된다.
- 블록문은 표현식이 아닌 문이다.
- var는 함수 안에서만 지역 변수이지 그 이외에 선언되면 지역 변수가 아니다. var는 함수 레벨 스코프만 인정한다. let, const는 블록 레벨 스코프이다. 
- 블록문(block statement/compound statement)는 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다. 문이 0개이면 빈 블록문이라고 부른다.


## 2. 조건문
### 2.1. if...else 문
### 2.2. switch 문
```js
switch (표현식) {
  case 표현식1:
  {
    switch 문의 표현식과 표현식1이 일치하면 실행될 문;
    break;
  }
  case 표현식2:
    switch 문의 표현식과 표현식2가 일치하면 실행될 문;
    break;
  default:
    switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;
}
```
- 위에서 표현식 1에는 블록이 있고 표현식 2에는 블록이 없다. 블록을 선언하는 경우 내부에 블록 스코프 변수를 선언할 수 있다는 장점이 있다. 
- 폴 스루(fall through):  switch 문을 탈출하지 않고 switch 문이 끝날 때까지 이후의 모든 case 문과 default 문을 실행하는 경우와 같은 것을 폴스루(fall through)라 한다.


## 3. 반복문
### 3.1. for 문
### 3.2. while 문
- for 문은 반복 횟수가 명확할 때 주로 사용하고 while 문은 반복 횟수가 불명확할 때 주로 사용한다.

## 4. break 문
- 레이블 문, 반복문, switch 문의 코드 블럭 외에 사용하면 에러가 난다.
- 2중 loop를 돌다가 탈출하고 싶을 때 레이블을 사용해서 탈출할 수 있음.
```js
// outer라는 식별자가 붙은 레이블 for 문
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    // i + j === 3이면 outer라는 식별자가 붙은 레이블 for 문을 탈출한다.
    if (i + j === 3) break outer;
    console.log(`inner [${i}, ${j}]`);
  }
}

console.log('Done!');
```

- 문자열은 유사배열 객체(iterable)이다. 
- 문자열은 length가 있기 때문에 for 문으로 순회할 수 있다.

## 5. continue 문
- continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. break 문처럼 반복문을 탈출하지는 않는다.
