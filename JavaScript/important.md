# 용어 정리

## [JavaScript]

- **문 (statement)**

    프로그램을 구성하는 기본 단위이자 최소 실행 단위

- **일시적 사각 지대 (Temporal Dead Zone)**

    스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

- **객체지향 프로그래밍 (Object Oriented Programming)**

    객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

- **객체 (object)**

    상태를 나타내는 데이터와 동작을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적인 자료구조

- **추상화 (abstraction)**
    - 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것
- **프로토타입 체인**

    상속과 프로퍼티 검색을 위한 메커니즘

- **스코프 체인**

    식별자 검색을 위한 메커니즘

- **프로퍼티 섀도잉 (property shadowing)**

    상속 관계에 의해 프로퍼티가 가려지는 현상

- **오버라이딩 (overriding)**

    상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 방식

- **오버로딩 (overloading)**

    함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메서드를 구현하고 매개변수에 의해 메서드를 구별하여 호출하는 방식

- **정적 프로퍼티 / 메서드**

    생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드

- **표준 빌트인 객체**

    ECMAScript 사양에 정의된 객체를 말하며, 애플리케이션 전역의 공통 기능을 제공

- **호스트 객체**

    EcmaScript 사양에 정의되어 있지 않지만 JS 실행 환경에서 추가로 제공하는 객체

    - Broswer : DOM, BOM ...
    - Node.js : file 관련
- **사용자 정의 객체**

    사용자가 직접 정의한 객체

- **래퍼 객체 (wrapper object)**

    문자열, 숫자, 불리언, 심벌 값에 대해 객체처럼 접근하면 생성되는 임시 객체

    - null, undefiend는 래퍼 객체를 생성하지 않음
- **전역 객체 (global object)**

    코드가 실행되기 이전 단계에 JS 엔진에 의해 어떤 객체보다 먼저 생성되는 특수한 객체

    어떤 객체에도 속하지 않은 최상위 객체

    - 프로토타입 상속 관계상에서 최상위 객체라는 말이 아님
        - 어떤 객체의 프로퍼티도 아니며, 객체의 계층적 구조상 표준 빌트인/호스트 객체를 프로퍼티로 소유한다는 의미
    - 환경에 따른 이름
        - broswer : window (self, this, frames, globalThis)
        - node.js : global
- **빌트인 전역 프로퍼티 (built-in global property)**

    전역 객체의 프로퍼티

- **빌트인 전역 함수 (built-in global function)**

    애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드

- **암묵적 전역 (implicit global)**

    전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작하는 현상

- **this**

    자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(self-referencing variable)

    this 바인딩은 함수 호출 방식에 의해 동적으로 결정

- **소스코드의 타입**
    - 전역 코드 (global code)
    - 함수 코드 (function code)
    - eval 코드 (eval code)
    - 모듈 코드 (module code)
- **실행 컨텍스트 (execution context)**

    식별자를 등록하고 관리하는 스코프와 코드 실행 순서를 구현한 내부 메커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.

    - 식별자와 스코프는 렉시컬 환경으로 관리
    - 코드 실행 순서는 실행 컨텍스트 스택으로 관리 (콜 스택이라고도 부름)
- **실행 중인 실행 컨텍스트 (running execution context)**

    실행 컨텍스트 스택 최상위에 존재하는 실행 컨텍스트

- **렉시컬 환경 (lexical environment)**

    스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체

- **렉시컬 스코프 (lexical scope)**

    상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정

    정적 스코프 (static scope) 라고도 함

- **환경 레코드 (environment record)**

    스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소

- **외부 렉시컬 환경에 대한 참조 (outer lexical environment reference)**

    외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킴

    단방향 링크드 리스트인 스코프 체인을 구현

- **식별자 결정 (identifier resolution)**

    어느 스코프의 식별자를 참조하면 되는 것인지 결정하는 것

    실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작

- **클로저 (closure)**

    (큰 의미) 함수와 그 함수가 선언된 렉시컬 환경과의 조합

    (일반적인 의미) 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정

    - 자유 변수 (free variable) → 클로저에 의해 참조되는 삼위 스코프의 변수
    - 사용 이유 → 상태를 안전하게 변경하고 유지하기 위해 사용
        - 상태를 안전하게 은닉 (information hiding)
        - 특정 함수에게만 상태 변경을 허용
- **캡슐화 (encapsulation)**

    객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것

    - 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는 이를 **정보 은닉**이라고 함
    - 결합도는 낮추고 응집도를 높여야 함
- **클래스의 constructor**

    인스턴스를 생성하고 초기화하기 위한 특수한 메서드

    이름 변경 불가

- **클래스 필드 (class field)**

    클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어

- **[[HomeObject]]**

    메서드 자신을 바인딩하고 있는 객체를 가리킴

    ES6 메서드 축약 표현으로 정의된 함수만이 가지고 있음

- **callable / constructor / non-constructor**
    - callable → 호출할 수 있는 함수 객체
    - constructor → 인스턴스를 생성할 수 있는 함수 객체
    - non-constructor → 인스턴스를 생성할 수 없는 함수 객체
- **화살표 함수 (arrow function)**

    function 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있음

    내부 동작도 기존의 함수보다 간략

- **Rest 파라미터**

    함수에 전달된 인수들의 목록을 배열로 전달받음

- **희소 배열 (sparse array)**

    배열의 요소가 연속적으로 이어져 있지 않는 배열

    - 희소 배열은 length와 배열 요소의 개수가 일치하지 않음
    - 희소 배열은 length는 희소 배열의 실제 요소 개수보다 언제나 큼
- **심벌 (symbol)**

    ES6에서 도입된 7번째 데이터 타입으로 변경 불가능한 원시 타입의 값

    심벌 값은 다른 값과 중복되지 않는 유일무이한 값

- **전역 심벌 레지스트리 (global symbol registry)**

    키와 심벌 값의 쌍들이 저장되어 있는 저장소

- **Well-Known Symbol**

    JS가 기본 제공하는 빌트인 심벌 값

- **이터레이션 프로토콜 (iteration protocol)**

    순회 가능한 데이터 컬렉션을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙

    데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 함

- **이터러블 프로토콜 (iterable protocol)**

    Well-Known Symbol인 Symbol.iterator를 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환하는 규약

- **이터레이터 프로토콜 (iterator protocol)**

    이터레이터는 next 메서드를 소유하며 next 메서드를 호출하면 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환

- **이터러블 (iterable)**

    이터러블 프로토콜을 준수한 객체

    for ...of 문으로 순회 가능, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용 가능

- **이터레이터 (iterator)**

    이터레이터 프로토콜을 준수한 객체

- **지연 평가 (lazy evaluation)**

    데이터가 필요한 시점 이전까지는 미리 데이터를 생성하지 않다가 데이터가 필요한 시점이 되면 그때야 비로소 데이터를 생성하는 기법

- **스프레드 문법 (spread syntax)**

    `...`은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록으로 만듬

    스프레드 문법의 결과는 값이 아니기 때문에 변수에 할당할 수 없음

    - 사용 가능한 곳
        - 함수 호출문의 인수 목록
        - 배열 리터럴의 요소 목록
        - 객체 리터럴의 프로퍼티 목록
- **디스트럭처링 할당 (destructuring assignment)**

    구조화된 배열과 같은 이터러블 또는 객체를 destructuring(비구조화)하여 1개 이상의 변수에 개별적으로 할당하는 것

- **Set 객체**

    중복되지 않는 유일한 값들의 집합

    - 배열과의 차이점
        - 동일한 값을 중복하여 포함할 수 없음
        - 요소 순서에 의미가 없음
        - 인덱스로 요소에 접근할 수 없음
- **Map 객체**

    키와 값의 쌍으로 이루어진 컬렉션

    - 일반 객체와의 차이점
        - 객체를 포함한 모든 값을 키로 사용 가능
        - 이터러블
        - map.size로 요소 개수 확인
- **토큰 (token)**

    문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

- **DOM (Document Object Model)**

    HTML 문서를 파싱한 결과물

- **렌더 트리 (Render Tree)**

    렌더 트리는 렌더링을 위한 트리 구조의 자료구조

    - 브라우저 화면에 렌더링되지 않는 노드(예: meta 태그, script 태그 등) X
    - CSS에 의해 비표시(예: display: none) X
- **리플로우 (Reflow)**

    레이아웃 계산을 다시 하는 것

    - 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한하여 실행
- **리페인트 (Repaint)**

    재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것

- **이벤트 전파 (event propagation)**

    DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파됨

- **캡처링 단계 (capturing phase)**

    이벤트가 상위 요소에서 하위 요소 방향으로 전파

- **타깃 단계 (target phase)**

    이벤트가 이벤트 타깃에 도달

- **버블링 단계 (bubbling phase)**

    이벤트가 하위 요소에서 상위 요소 방향으로 전파

- **호출 스케줄링 (scheduling a call)**

    함수를 명시적으로 호출하지 않고 일정 시간이 경과된 이후에 호출되도록 함수 호출을 예약하려면 타이머 함수를 사용

- **디바운드 / 스로틀**

    짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법

    - 디바운스 (debounce) → 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트ㅡ 핸들러가 호출되도록 함
    - 스로틀 (throttle) → 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만듬
- **동기 처리 (synchronous)**

    현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식

    - 장점 : 실행 순서가 보장됨
    - 단점 : 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹 됨
- **비동기 처리 (asynchronous)**

    현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식

    - 장점 : 블로킹이 발생하지 않음
    - 단점 : 실행 순서가 보장되지 않음
- **태스크 큐 (task queue / event queue / callback queue)**

    setTimeout 이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역

- **이벤트 루프 (event loop)**

    콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인

    콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.

- **비동기**

    동기 처리가 아닌 처리를 비동기라고 함

    - 동기 처리 : 콜스택에 순서대로 삽입됨
- **Ajax (Asynchronous Javascript And XML)**
    - 자바스크립트를 활용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청
    - 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱싱하는 프로그래밍 방식
- **JSON (JavaScript Object Notation)**

    클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷

    - 자바스크립트에 종속되지 않는 언어 독립형 데이터 포맷
- **직렬화 (serializing)**

    클라이언트가 서버로 객체를 전송하기 위해 객체를 문자열화하는 것

- **역직렬화 (deserializing)**

    서버로부터 클라이언트에게 전송된 JSON 데이터 문자열을 객체로서 사용하기 위해 JSON 포맷의 문자열을 객체화하는 것

- **REST (REpresentational State Transfer)**

    HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처

- **REST API**

    REST를 기반으로 서비스 API를 구현한 것을 의미

    - 구성 요소 : 자원(resource), 행위(verb), 표현(representations)
    - GET : 자료 가져옴
    - POST : 생성
    - PUT : 전체 수정
    - PATCH : 일부 수정
- **콜백 헬 (callback hell)**

    콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또 다시 비동기 함수를 홑출해야 한다면 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상

- **프로미스 (promise)**

    비동기 처리 상태와 처리 결과를 관리하는 객체

    - Promise는 디버깅, 예외 처리 (try/catch 대신 catch메서드 사용), 들여쓰기로 인한 가독성 하락 등의 문제
- **async / await**

    프로미스를 기반으로 동작

    - 마치 동기 처리처럼 프로미스를 사용할 수 있다. 다시 말해, 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현
    - async 함수는 async 키워드를 사용해 정의하며 언제나 프로미스를 반환
        - async 함수가 명시적으로 프로미스를 반환하지 않더라도 async 함수는 암묵적으로 반환값을 resolve하는 프로미스를 반환
        - async 함수 내에서 catch 문을 사용해서 에러 처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환
    - await 키워드는 반드시 async 함수 내부에서 사용
        - await 키워드는 프로미스가 settled 상태(비동기 처리가 수행된 상태)가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환
        - await 키워드는 반드시 프로미스 앞에서 사용
- **바벨 (Babel)**

    트랜스파일러(transpiler)

    - ES6+/ES.NEXT로 구현된 최신 사양의 소스코드를 IE 같은 구형 브라우저에서도 동작하는 ES5 사양의 소스코드로 변환(트랜스파일링)
    - @babel/preset-env는 함께 사용되어야 하는 Babel 플러그인을 모아 둔 것으로 Babel 프리셋(preset)
        - 타겟 브라우저를 입력하면 알아서 사용자가 환경에 맞춰 최신 EcmaScript를 사용할 수 있게 해준다.
    - @babel/polyfill
        - Promise, Object.assign, Array.from 등과 같이 ES5 사양으로 대체할 수 없는 기능은 트랜스파일링되지 않는다.
        - IE 같은 구형 브라우저에서도 Promise, Object.assign, Array.from 등과 같은 객체나 메서드를 사용하기 위해서는 @babel/polyfill을 설치해야 한다.
- **Webpack**

    모듈 번들러(module bundler)

### [지식 백과]

- **전역 변수의 문제점**
    - 암묵적 결합
    - 긴 생명 주기
    - 스코프 체인 상에서 종점에 존재
    - 네임스페이스 오염
- **일급 객체의 특성**
    - 무명의 리터럴로 생성할 수 있음. 즉, 런타임에 생성이 가능
    - 변수나 자료구조에 저장할 수 있음
    - 함수의 매개변수에게 전달 가능
    - 함수의 반환값으로 사용 가능
- **strict mode가 발생시키는 에러**
    - 암묵적 전역
    - 변수, 함수, 매개변수의 삭제
    - 매개변수 이름의 중복
    - with 문의 사용
- **클래스의 생성자 함수와의 차이점**
    - new 연산자 없이 호출하면 에러 발생
    - 상속을 지원하는 extends와 super 키워드를 제공
    - 호이스팅이 발생하지 않는 것처럼 동작
    - 클래스 내의 모든 코드는 암묵적으로 strict mode가 지정되어 실행
    - 클래스 내의 constructor, 프로토타입 메서드, 정적 메서드는 [[Enumerable]] 의 값이 false
- **클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티**

    이름이 같아 혼동하기 쉽지만 직접적인 관련이 없음

    - 프로토타입의 constructor 프로퍼티는 모든 프로토타입이 가지고 있는 프로퍼티이며, 생성자 함수를 가리킴
- **정적 메서드와 프로토타입 메서드의 차이**
    - 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다름
    - 정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출
    - 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있음
- **클래스에서 정의한 메서드의 특징**
    - function 키워드를 생략한 메서드 축약 표현을 사용
    - 객체 리터럴과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없음
    - 암묵적으로 strict 모드로 실행
    - [[Enumerable]] 값이 false
    - 내부 메서드 [[Construct]]를 갖지 않는 non-constructor
- **super 호출할 때 주의사항**
    - 서브클래스에서 constructor를 생략하지 않는 경우 서브클래스의 constructor에서는 반드시 super를 호출해야 함
        - 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임하기 때문에
    - 서브클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없음
    - super는 반드시 서브클래스의 constructor에서만 호출한다.
        - 서브클래스가 아닌 클래스의 constructor나 함수에서 super를 호출하면 에러 발생
- **ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출 가능**
    - 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성하기 때문에 혼란스러우며 실수 유발 가능 및 성능 저하
- **ES6 사양에서의 메서드**

    메서드 축약 표현으로 정의된 함수만을 의미

- **화살표 함수와 일반 함수의 차이**
    - 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor
        - prototype 프로퍼티가 없고 프로토타입도 생성하지 않음
    - 중복된 매개변수 이름을 선언할 수 없음
    - this, arguments, super, new.target 바인딩을 갖지 않음
- **이벤트 핸들러 등록 방식의 종류**
    - 이벤트 핸들러 어트리뷰트 방식
    - 이벤트 핸들러 프로퍼티 방식
    - addEventListener 메서드 방식
- **비동기 처리를 위한 콜백 패턴의 단점**
    - 콜백 헬
    - 에러 처리의 한계
