# 원시값과 객체의 비교
- 자바스크립트가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, 심벌, 객체 타입)은 크게 원시 타입과 객체 타입으로 구분할 수 있다.
- 만약 과거에 메모리 값이 쌌다면 객체를 원시값처럼 사용했을 수 도 있을 것이다. 객체를 원시값처럼 쓰고자 하는 욕구가 있다.
- **원시 타입의 값, 즉 원시값은 변경 불가능한 값(immutable value)이다.**
- **객체(참조)타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.**
- 메모리 주소가 바뀌는가 안바뀌는가가 중요하다. 
- 원시값을 변수에 할당하면 변수에는 실제 값이 저장한다. 이에 비해 객체를 변수에 할당ㅎ마ㅕㄴ 변수에는 참조값이 저장된다.
- 참조 값은 원시 값이다. 결국은 객체를 할당한 변수나, 원시값을 할당한 변수나 실제 메모리 주소에는 원시값이 들어가 있다.
- 원시값을 갖는 변수를 다른 변수에 할당하며 원본의 값이 복사되어 전달된다. 이를 값에 의한 전달(pass by value)이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다. 이를 참조에 의한 전달(pass by value)이라 한다.

## 1. 원시값
### 1.1. 변경 불가능한 값
- 원시값은 재할당하지 않으면 절대 값이 바뀌지 않는다. 
- **불변성을 갖는 원시값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**

### 1.2. 문자열과 불변성
- 다른 언어는 문자열이 원시값이 아니다. C는 배열로 표기하고 java는 객체로 표현한다. java에서는 문자열이 불변 객체가 된다.
```js
var str = 'hello';
var newStr = str.toUpperCase(); // str의 값이 바뀌지는 않는다.
console.log(newStr);
```

- 항상 불변성을 유지하려고 노력하자.
```js
var arr = [];
arr.push(0); // arr가 바뀜.
console.log(arr);
console.log([...arr, 1]); // spread 연산자를 사용해서 arr를 바꾸지 않음.
```
- 문자열 메서드는 항상 새로운 문자열을 return 한다. 문자열은 원시값이기 때문에 값은 변경되지 않는다.
- String 생성자는 유사 배열 객체를 만든다.

### 1.3. 값에 의한 전달
```js
var score = 80;
var copy = score;
```
- 위 코드에서 score는 식별자 표현식으로 숫자 값 80으로 평가된다. 이때 두가지 평가 방식이 가능하다.
  - 첫번째, 새로운 80을 생성(복사)해서 메모리 주소를 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 다르다.
  - 두번째, score의 변수값 80의 메모리 주소를 그대로 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 같다.

- **이처럼 "값의 의한 전달"도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.**
- **두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.**
- **엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 때문이다. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.**
- js는 원시값은 스택에, 객체는 힙에 저장되는 것 같은데 C언어와는 달리 js는 확실하지 않다.


## 2. 객체
- 값은 게으르게 만든다. 
```js
var person = {
  name: 'Lee',
}
```
- 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다. 
- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조값(reference value)** 에 접근할 수 있다. 참조값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다. 


- 얕은 복사 vs 깊은 복사
```js
const o = {
  a: {
    b: 2
  },
  f() {}
};

// 얕은 복사
let c = { ...o }; // "35. 스프레드 문법" 참고
console.log(o === c); // false
console.log(o.a === c.a); // true

// 얕은 복사
c = Object.assign({}, o);
console.log(o === c); // false
console.log(o.a === c.a); // true

// JSON.parse와 JSON.stringify를 사용한 깊은 복사
c = JSON.parse(JSON.stringify(o));
console.log(o === c); // false
console.log(o.a === c.a); // false
// 메서드가 사라진다!
console.log(c.f); // undefined

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash');

c = _.cloneDeep(o);
console.log(o === c); // false
console.log(o.a === c.a); // false
console.log(c.f); // f
```
- js에서 제공하는 모든 복사는 얕은 복사이다. 깊은 복사를 할 것이면 라이브러리를 사용해야 한다.
- 왜 기본적으로 얕은 복사가 일어날까? 만약 기본 동작이 깊은 복사라면, 1000개의 깊이로 객체가 있다면 어떡할 것인가? 그렇게 되면 복사할 객체를 1000개 만들어야 한다. 매우 비효율적이고 메모리에 과부화가 걸릴 수 있다. 그러므로 기본적으로 얕은 복사가 일어난다. **가장 top level 객체만 복사한다.**
- 깊은 복사를 사용하려고 할 때 라이브러리를 사용한다. 실무에서는 만들기보단 라이브러리를 써야한다. 역사와 전통이 있는 라이브러리 즉, 퍼포먼스가 좋다고 인정된 라이브러리를 쓰는 것이 안정적이다. 대표적인 라이브러리로 cloneDeep의 loadash가 있다. 
 
- 얕은 복사는 여러가지 방법이 있다. 스프레드 연산자를 사용할 수도 있고, Object.assign을 사용할 수 있다. 스프레드 연산자는 정식 문법이 아니지만 Object.assign은 정식 문법이다. 하지만 스프레드 연산자를 많이 사용한다.
- 깊은 복사 방식 중 JSON.parse, JSON.stringify를 사용 하는 경우는 메서드가 사라진다. 따라서 loadsh 라이브러리를 사용한다.

```js
const v = 1;

// "깊은 복사"라고 부르기도 한다.
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1 };

// "얕은 복사"라고 부르기도 한다.
const c2 = o;
console.log(c2 === o); // true
```
